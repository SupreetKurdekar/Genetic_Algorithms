## this file contains all the utilities functions

import struct
import numpy as np
import random
import fitness_function
import math
import pandas as pd
import copy
from statistics import stdev
from matplotlib import animation
from matplotlib import pyplot as plt
from matplotlib.animation import FuncAnimation

def float_to_bin(num):
    return format(struct.unpack('!I', struct.pack('!f', num))[0], '032b')

def bin_to_float(binary):
    return struct.unpack('!f',struct.pack('!I', int(binary, 2)))[0]

def scaling_seed_designs(init_designs,variable_bounds):
    # scaling to required variable bounds
    scaled_designs = []
    for design in init_designs:
        temp = np.multiply(design,(variable_bounds[0]-variable_bounds[1]))
        scaled_designs.append(temp)

    scaled_designs = np.array(scaled_designs)

    # adding lower bounds
    for id,design_row in enumerate(scaled_designs):
        design_row = np.add(design_row,variable_bounds[1])
        scaled_designs[id] = design_row
    
    return scaled_designs

# returns a tuple of decimal value, binary string and precision digits
def variableEncoder(var_value,precision_digits):
    #bin_value = format(np.around(var_value*(10**precision_digits)).astype(np.int64), "b")
    bin_value = np.binary_repr(np.around(var_value*(10**precision_digits)).astype(np.int64))
    # print("number converted",round(var_value*(10**precision_digits)))
    return [round(var_value,precision_digits),bin_value,len(bin_value)]

# returns a tuple of decimal value, binary string and precision digits
def variableDecoder(bin_value,precision_digits):
    dec_val = int(bin_value,base=2)
    dec_val = dec_val*(10**-precision_digits)
    return [dec_val,bin_value,len(bin_value)]

def getDesignFromString(des_string,listOfVarStringLengths,listOfPrecisionDigits):
    lb = 0
    ub = 0
    design = []
    for id,length in enumerate(listOfVarStringLengths):
        ub = lb+length
        design.append(variableDecoder(des_string[lb:ub],listOfPrecisionDigits[id]))
        lb = ub

    return design

## generate a population. Population is a dictionary.
# dictionary element key is design id number.
# dictionary element value is a list of design_variables
# design_variable is a list of real value,binary string and number of precision digits used.
# Function requires the array of init_designs generated by the pyDOE lhs function
# and a list of integers defining the required amount of precision 
def pop_generator(init_designs,listOfPrecisionDigits):
    population = {}
    for id,design in enumerate(init_designs):
        design_list = []
        
        for des_var,precision_digits in zip(design,listOfPrecisionDigits):
            des_var = variableEncoder(des_var,precision_digits)
            # design_string = design_string + des_var[1]
            design_list.append(des_var) # design_list is the design


        population[id] = design_list

    return population

# function to make each variable in population have the same string length
def equaliseVariableStringLength(population,num_var):
    for var_number in range(num_var):
        max_length = 0

        # finding max length
        for design_key in population:
            current_length = population[design_key][var_number][2]

            if current_length > max_length:
                max_length = current_length
        
        # now make all lengths equal to max length by
        # adding zeros at the beginning
        # number of zeros equal to difference
        for design_key in population:
            # print(population[design_key][var_number])
            current_length = (population[design_key][var_number][2])
            diff = max_length - current_length
            population[design_key][var_number][1] = population[design_key][var_number][1].rjust(diff+len(population[design_key][var_number][1]),'0')
            # print(population[design_key][var_number][1])
            population[design_key][var_number][2] = max_length

    return population

# function to get overall string of a design
def getDesignString(design):
    design_string = ""
    for variable in design:
        design_string = design_string + variable[1]
    
    return design_string

def singlePointCrossover(id1,id2,listOfVarStringLengths,listOfPrecisionDigits,population):
    parent1 = population[id1]
    parent2 = population[id2]

    string1 = getDesignString(parent1)
    string2 = getDesignString(parent2)

    crossover_point = random.randrange(0,len(string1))
    child_string1 = string1[0:crossover_point] + string2[crossover_point:]
    child_string2 = string2[0:crossover_point] + string1[crossover_point:]

    child_design1 = getDesignFromString(child_string1,listOfVarStringLengths,listOfPrecisionDigits)
    child_design2 = getDesignFromString(child_string2,listOfVarStringLengths,listOfPrecisionDigits)

    population[id1] = child_design1
    population[id2] = child_design2

    #return crossover_point

def twoPointCrossover(id1,id2,listOfVarStringLengths,listOfPrecisionDigits,population):
    parent1 = population[id1]
    parent2 = population[id2]

    string1 = getDesignString(parent1)
    string2 = getDesignString(parent2)

    crossover_point = random.randrange(0,len(string1))
    child_string1 = string1[0:crossover_point] + string2[crossover_point:]
    child_string2 = string2[0:crossover_point] + string1[crossover_point:]

    crossover_point2 = random.randrange(crossover_point,len(string1))
    final_child_string1 = child_string1[0:crossover_point2] + child_string2[crossover_point2:]
    final_child_string2 = child_string2[0:crossover_point2] + child_string1[crossover_point2:]

    child_design1 = getDesignFromString(final_child_string1,listOfVarStringLengths,listOfPrecisionDigits)
    child_design2 = getDesignFromString(final_child_string2,listOfVarStringLengths,listOfPrecisionDigits)

    population[id1] = child_design1
    population[id2] = child_design2

# mating pool is a dictionary
# repeated candidates will not affect
# as they will have different keys
# crossoverProbability is a number between 0 and 1
# this number is the probability of crossover
def generalCrossover(crossoverProbability,MatingPool,crossover_function,listOfVarStringLengths,listOfPrecisionDigits):
    matingPoolIds = list(MatingPool.keys())
    # print("len of mating ids",len(matingPoolIds))
    while len(matingPoolIds) > 1:
        id1 = matingPoolIds.pop(random.randint(0, len(matingPoolIds)-1))
        # print("nums_len",len(matingPoolIds))
        id2 = matingPoolIds.pop(random.randint(0, len(matingPoolIds)-1))
        if random.random() < crossoverProbability:
            crossover_function(id1,id2,listOfVarStringLengths,listOfPrecisionDigits,MatingPool)

def mutation(MatingPool,mutationProbability,listOfVarStringLengths,listOfPrecisionDigits):
    for des_id in MatingPool:
        design_string = getDesignString(MatingPool[des_id])
        new_string = ""
        for bit in design_string:
            if random.random() < mutationProbability:
                if bit == '1':
                    new_string = new_string + '0'
                elif bit == '0':
                    new_string = new_string + '1'
            else:
                new_string = new_string + bit
            
        MatingPool[des_id] = getDesignFromString(new_string,listOfVarStringLengths,listOfPrecisionDigits)

# scores is a dictionary of ids and function values
def fitnessEvaluation(population,variable_bounds,beta,cost_fcn,df
,iterationNUmber,listOfVariableHeadings,numVar): # needs to account for constraints too

    scaledPopulation = scaledPopulationGenerator(population,variable_bounds)
    # print("scaledPopulation",scaledPopulation)
    scaled_variables_values_list = []
    for i in scaledPopulation:
        design = scaledPopulation[i]
        temp = [x[0] for x in design]
        scaled_variables_values_list.append(temp)
    # print("scaled_variables",scaled_variables_values_list)
    scores = {}
    max_score = -100000000000
    for des_id in population:
        scores[des_id] = cost_fcn(scaledPopulation[des_id])
        if scores[des_id] > max_score:
            max_score = scores[des_id]
    
    scores_list = list(scores.values())
    # FunctionValue=pd.DataFrame(scores_list,columns="FunctionValue")
    
    constraint_violation = []
    for des_id in population:
        constraint_violation.append(fitness_function.variableBoundsConstraint(scaledPopulation[des_id],variable_bounds))
    
    for des_id,con_Vi in zip(scores,constraint_violation):
        if con_Vi != 0:
            scores[des_id] = max_score + con_Vi

    fitness_scores = {}
    max_score = max(list(scores.values()))
    for id in scores:
        # fitness_scores[id] = math.exp(beta*(-scores[id]/max_score))
        fitness_scores[id] = max_score-scores[id]
        # print(math.exp(beta*(-scores[id]/max(scores))))
    fitnessScoresList = list(fitness_scores.values())

    gen = [iterationNUmber]*len(population)
    newDF = pd.DataFrame(list(zip(gen,scores_list,fitnessScoresList,constraint_violation)), 
               columns =listOfVariableHeadings)

    varDF = pd.DataFrame(scaled_variables_values_list)

    newCompleteDf = pd.concat([newDF, varDF], axis=1)
    
    df = pd.concat([df,newCompleteDf],axis = 0,ignore_index=True)

    return fitness_scores,df

def tournament_selection(scores,population):
    mating_pool = {}
    count = 0
    set1 = list(scores.keys())
    while len(set1) > 0:
        pair = [set1.pop(random.randrange(len(set1))) for _ in range(2)]
        # before this implement constraint sum comparison
        # if this is valid, then no function value comparison will be done
        # this is function value comparison
        if scores[pair[0]]>scores[pair[1]]:
            mating_pool[count] = population[pair[0]]
            count = count + 1
        elif scores[pair[0]]<=scores[pair[1]]:
            mating_pool[count] = population[pair[1]]
            count = count + 1
    
    set1 = list(scores.keys())
    while len(set1) > 0:
        pair = [set1.pop(random.randrange(len(set1))) for _ in range(2)]
        # before this implement constraint sum comparison
        # if this is valid, then no function value comparison will be done
        # this is function value comparison
        if scores[pair[0]]>scores[pair[1]]:
            mating_pool[count] = population[pair[0]]
            count = count + 1
        elif scores[pair[0]]<=scores[pair[1]]:
            mating_pool[count] = population[pair[1]]
            count = count + 1

    return mating_pool

# stochastoc universal sampling
def suss(scores,population,listOfVarStringLengths):
    values = scores.values()
    #print("values",values)
    # print(values)
    # code smell - all values are zero - sum doesnt work
    if sum(values) == 0:
        norm_values = [1/len(values) for i in values]
    else:    
        norm_values = [float(i)/sum(values) for i in values]

    r = random.random()
    limits = []
    lsum = 0
    for i in norm_values:
        limits.append(lsum + i)
        lsum = lsum + i

    index=0
    mating_pool = {}
    index_stored = []
    while len(mating_pool) < len(population):
        for id,limit in enumerate(limits):
            if r <= limit:
                mating_pool[index] = population[id]
                index = index + 1
                r = (r + 1/len(population))%1
                index_stored.append(id)
                break

    return mating_pool
    
def scaledPopulationGenerator(population,variable_bounds):
    # scaledPopulation = {}
    scaledPopulation = copy.deepcopy(population)
    for id in population:
        design = population[id]
        
        for varNumber,var in enumerate(design):
            # scaledPopulation.append(population[id])
            temp = var[0]*(variable_bounds[0][varNumber]-variable_bounds[1][varNumber]) + variable_bounds[1][varNumber]
            scaledPopulation[id][varNumber][0] = temp
            
    return scaledPopulation

def animate(generation_number,df):
    data = df.loc[df['GenerationNumber']==generation_number,:]
    print("data",data)

    x = data['GenerationNumber']
    y1 = data['MinFunctionValue']
    y2 = data['AverageFunctionValue']
    plt.cla()

    plt.plot(x,y1, label='MinFunctionValue')
    plt.plot(x,y2, label='AverageFunctionValue')

    plt.legend(loc='upper right')
    plt.tight_layout()